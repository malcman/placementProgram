{"version":3,"file":"index.es.js","sources":["../src/flip/animateUnflippedElements/index.ts","../src/utilities/index.ts","../src/springSettings/index.ts","../src/forked-rebound/onFrame.js","../src/flip/animateFlippedElements/filterFlipDescendants.ts","../src/forked-rebound/util.js","../src/forked-rebound/Loopers.js","../src/forked-rebound/Spring.js","../src/forked-rebound/SpringSystem.js","../src/flip/animateFlippedElements/spring/index.ts","../src/flip/animateFlippedElements/initiateAnimations.ts","../src/flip/animateFlippedElements/index.ts","../src/flip/getFlippedElementPositions/utilities.ts","../src/Flipper/index.tsx","../src/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts","../src/flip/index.ts","../src/flip/getFlippedElementPositions/getFlippedElementPositionsAfterUpdate/index.ts","../src/constants.ts","../src/Flipped/index.tsx","../src/ExitContainer/index.tsx"],"sourcesContent":["import { AnimateUnflippedElementsArgs, FragmentTuple } from './types'\n\nconst animateUnflippedElements = ({\n  unflippedIds,\n  flipCallbacks,\n  getElement,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  inProgressAnimations\n}: AnimateUnflippedElementsArgs) => {\n  const enteringElementIds = unflippedIds.filter(\n    id => flippedElementPositionsAfterUpdate[id]\n  )\n  const animatedEnteringElementIds = enteringElementIds.filter(\n    id => flipCallbacks[id] && flipCallbacks[id].onAppear\n  )\n\n  const animatedExitingElementIds = unflippedIds.filter(\n    id =>\n      flippedElementPositionsBeforeUpdate[id] &&\n      flipCallbacks[id] &&\n      flipCallbacks[id].onExit\n  )\n\n  // make sure appearing elements aren't taken into account by the filterFlipDescendants function\n  enteringElementIds.forEach(id => {\n    const element = getElement(id)\n    if (element) {\n      element.dataset.isAppearing = 'true'\n    }\n  })\n\n  const hideEnteringElements = () => {\n    animatedEnteringElementIds.forEach(id => {\n      const element = getElement(id)\n      if (element) {\n        element.style.opacity = '0'\n      }\n    })\n  }\n\n  const animateEnteringElements = () => {\n    animatedEnteringElementIds.forEach((id, i) => {\n      const element = getElement(id)\n      if (element) {\n        flipCallbacks[id].onAppear!(element, i)\n      }\n    })\n  }\n\n  let closureResolve: () => void\n\n  const promiseToReturn: Promise<void> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n\n  const fragmentTuples: FragmentTuple[] = []\n  let exitingElementCount = 0\n\n  const onExitCallbacks = animatedExitingElementIds.map((id, i) => {\n    const {\n      domDataForExitAnimations: {\n        element,\n        parent,\n        childPosition: { top, left, width, height }\n      }\n    } = flippedElementPositionsBeforeUpdate[id]\n    // insert back into dom\n    if (getComputedStyle(parent).position === 'static') {\n      parent.style.position = 'relative'\n    }\n    element.style.transform = 'matrix(1, 0, 0, 1, 0, 0)'\n    element.style.position = 'absolute'\n    element.style.top = top + 'px'\n    element.style.left = left + 'px'\n    // taken out of the dom flow, the element might have lost these dimensions\n    element.style.height = height + 'px'\n    element.style.width = width + 'px'\n    let fragmentTuple: FragmentTuple | undefined = fragmentTuples.filter(\n      t => t[0] === parent\n    )[0]\n    if (!fragmentTuple) {\n      fragmentTuple = [parent, document.createDocumentFragment()]\n      fragmentTuples.push(fragmentTuple)\n    }\n    fragmentTuple[1].appendChild(element)\n\n    exitingElementCount += 1\n\n    const stop = () => {\n      try {\n        parent.removeChild(element)\n      } catch (DOMException) {\n        // the element is already gone\n      } finally {\n        exitingElementCount -= 1\n        if (exitingElementCount === 0) {\n          closureResolve()\n        }\n      }\n    }\n    inProgressAnimations[id] = { stop }\n    return () => flipCallbacks[id].onExit!(element, i, stop)\n  })\n\n  // now append all the fragments from the onExit callbacks\n  // (we use fragments for performance)\n  fragmentTuples.forEach(t => {\n    t[0].appendChild(t[1])\n  })\n\n  if (!onExitCallbacks.length) {\n    closureResolve!()\n  }\n\n  const animateExitingElements = () => {\n    onExitCallbacks.forEach(c => c())\n    return promiseToReturn\n  }\n\n  return {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  }\n}\n\nexport default animateUnflippedElements\n","import { IndexableObject } from './types'\n\nexport const isNumber = (x: any) => typeof x === 'number'\n\nexport const isFunction = (x: any) => typeof x === 'function'\n\nexport const isObject = (x: any) =>\n  Object.prototype.toString.call(x) === '[object Object]'\n\nexport const toArray = (arrayLike: ArrayLike<any>) =>\n  Array.prototype.slice.apply(arrayLike)\n\nexport const getDuplicateValsAsStrings = (arr: string[]): string[] => {\n  const baseObj: IndexableObject = {}\n  const obj = arr.reduce((acc, curr) => {\n    acc[curr] = (acc[curr] || 0) + 1\n    return acc\n  }, baseObj)\n  return Object.keys(obj).filter(val => obj[val] > 1)\n}\n\n// tslint only likes this with a regular function, not an arrow function\nexport function assign(\n  target: IndexableObject,\n  ...args: IndexableObject[]\n): object {\n  args.forEach(arg => {\n    if (!arg) {\n      return\n    }\n    // Skip over if undefined or null\n    for (const nextKey in arg) {\n      // Avoid bugs when hasOwnProperty is shadowed\n      if (Object.prototype.hasOwnProperty.call(arg, nextKey)) {\n        target[nextKey] = arg[nextKey]\n      }\n    }\n  })\n  return target\n}\n","import { isObject, assign } from '../utilities'\nimport { SpringPresets, SpringConfig, SpringOption } from './types'\n\n// adapted from\n// https://github.com/chenglou/react-motion/blob/master/src/presets.js\nexport const springPresets: SpringPresets = {\n  noWobble: { stiffness: 200, damping: 26 },\n  gentle: { stiffness: 120, damping: 14 },\n  veryGentle: { stiffness: 130, damping: 17 },\n  wobbly: { stiffness: 180, damping: 12 },\n  stiff: { stiffness: 260, damping: 26 }\n}\n\nfunction argIsSpringConfig(\n  arg: SpringConfig | keyof SpringPresets | undefined\n): arg is SpringConfig {\n  return isObject(arg)\n}\n\nexport const getSpringConfig = ({\n  flipperSpring,\n  flippedSpring\n}: { flipperSpring?: SpringOption; flippedSpring?: SpringOption } = {}) => {\n  const normalizeSpring = (\n    spring?: SpringConfig | keyof SpringPresets | any\n  ) => {\n    if (argIsSpringConfig(spring)) {\n      return spring\n    } else if (Object.keys(springPresets).indexOf(spring) > -1) {\n      return springPresets[spring]\n    } else {\n      return {}\n    }\n  }\n\n  return assign(\n    {},\n    springPresets.noWobble,\n    normalizeSpring(flipperSpring),\n    normalizeSpring(flippedSpring)\n  )\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nlet _onFrame\nif (typeof window !== \"undefined\") {\n  _onFrame = window.requestAnimationFrame\n}\n\n_onFrame =\n  _onFrame ||\n  function(callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\nexport default _onFrame\n","import { toArray } from '../../utilities'\nimport * as constants from '../../constants'\nimport { ScopedSelector, LevelToChildren, FlipDataDict } from './types'\nimport { FlippedIds } from '../types'\n\n// scoped selector makes sure we're querying inside the right Flipper\n// container, either internally or with the right portal key\nconst selectFlipChildIds = (\n  scopedSelector: ScopedSelector,\n  selector: string,\n  flippedIds: FlippedIds\n): string[] => {\n  const childIds = scopedSelector(selector).map(\n    (el: HTMLElement) => el.dataset.flipId\n  )\n  // now return an array ordered by the original order in the DOM\n  return flippedIds.filter(id => childIds.indexOf(id) > -1)\n}\n\nconst baseSelector = `[${constants.DATA_FLIP_ID}]:not([${\n  constants.DATA_IS_APPEARING\n}])`\n\nexport default ({\n  flipDataDict,\n  flippedIds,\n  scopedSelector\n}: {\n  flipDataDict: FlipDataDict\n  flippedIds: FlippedIds\n  scopedSelector: ScopedSelector\n}) => {\n  const levelToChildren: LevelToChildren = {}\n\n  const buildHierarchy = (\n    selector: string,\n    level: number,\n    oldResult: string[]\n  ) => {\n    const newSelector = `${selector} ${baseSelector}`\n    // make sure this is scoped to the Flipper element in case there are\n    // mulitiple Flipper elements on the page\n    const newResult = selectFlipChildIds(\n      scopedSelector,\n      newSelector,\n      flippedIds\n    )\n\n    const oldLevelChildren = oldResult.filter(\n      id => newResult.indexOf(id) === -1\n    )\n    levelToChildren[level] = oldLevelChildren\n    oldLevelChildren.forEach(childId => {\n      if (flipDataDict[childId]) {\n        flipDataDict[childId].level = level\n      }\n    })\n\n    if (newResult.length !== 0) {\n      buildHierarchy(newSelector, level + 1, newResult)\n    }\n  }\n\n  // the top level selectChildFlipIds should use the scopedSelector\n  buildHierarchy(\n    baseSelector,\n    0,\n    selectFlipChildIds(scopedSelector, baseSelector, flippedIds)\n  )\n\n  // now make sure childIds in each flippedData contains only direct children\n  // since to enable nested stagger we want each parent to be able to kick off\n  // the animations only for its direct children\n  Object.keys(flipDataDict).forEach(flipId => {\n    const data = flipDataDict[flipId]\n    // scope by parent element\n    data.childIds = selectFlipChildIds(\n      selector => toArray(data.element.querySelectorAll(selector)),\n      baseSelector,\n      flippedIds\n    )\n\n    data.childIds = data.childIds.filter(\n      id =>\n        levelToChildren[data.level + 1] &&\n        levelToChildren[data.level + 1].indexOf(id) > -1\n    )\n  })\n  return levelToChildren['0']\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport _onFrame from \"./onFrame\"\n\n// Cross browser/node timer functions.\nexport function onFrame(func) {\n  return _onFrame(func)\n}\n\nconst start = Date.now()\nexport const performanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\"\n    ? () => performance.now()\n    : () => Date.now() - start\n\n// Lop off the first occurence of the reference in the Array.\nexport function removeFirst(array, item) {\n  const idx = array.indexOf(item)\n  idx !== -1 && array.splice(idx, 1)\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { onFrame, performanceNow } from \"./util\"\n\n/**\n * Plays each frame of the SpringSystem on animation\n * timing loop. This is the default type of looper for a new spring system\n * as it is the most common when developing UI.\n * @public\n */\nexport class AnimationLooper {\n  run() {\n    onFrame(() => {\n      this.springSystem.loop(performanceNow())\n    })\n  }\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { removeFirst } from \"./util\"\n\nclass PhysicsState {\n  constructor() {\n    this.position = 0\n    this.velocity = 0\n  }\n}\n\n/**\n * Provides a model of a classical spring acting to\n * resolve a body to equilibrium. Springs have configurable\n * tension which is a force multipler on the displacement of the\n * spring from its rest point or `endValue` as defined by [Hooke's\n * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have\n * configurable friction, which ensures that they do not oscillate\n * infinitely. When a Spring is displaced by updating it's resting\n * or `currentValue`, the SpringSystems that contain that Spring\n * will automatically start looping to solve for equilibrium. As each\n * timestep passes, `SpringListener` objects attached to the Spring\n * will be notified of the updates providing a way to drive an\n * animation off of the spring's resolution curve.\n * @public\n */\nclass Spring {\n  constructor(springSystem) {\n    this._id = \"s\" + Spring._ID++\n    this._springSystem = springSystem\n\n    this.listeners = []\n    this._startValue = 0\n\n    this._currentState = new PhysicsState()\n    this._displacementFromRestThreshold = 0.001\n    this._endValue = 0\n    this._overshootClampingEnabled = false\n    this._previousState = new PhysicsState()\n    this._restSpeedThreshold = 0.001\n\n    this._tempState = new PhysicsState()\n    this._timeAccumulator = 0\n    this._wasAtRest = true\n  }\n\n  getId() {\n    return this._id\n  }\n\n  /**\n   * Remove a Spring from simulation and clear its listeners.\n   * @public\n   */\n  destroy() {\n    this.listeners = []\n    this._springSystem.deregisterSpring(this)\n  }\n\n  /**\n   * Set the configuration values for this Spring. A SpringConfig\n   * contains the tension and friction values used to solve for the\n   * equilibrium of the Spring in the physics loop.\n   * @public\n   */\n  setSpringConfig(springConfig) {\n    this._springConfig = springConfig\n    return this\n  }\n  /**\n   * Retrieve the current value of the Spring.\n   * @public\n   */\n  getCurrentValue() {\n    return this._currentState.position\n  }\n\n  /**\n   * Get the absolute distance of the Spring from a given state value\n   */\n  getDisplacementDistanceForState(state) {\n    return Math.abs(this._endValue - state.position)\n  }\n\n  /**\n   * Set the endValue or resting position of the spring. If this\n   * value is different than the current value, the SpringSystem will\n   * be notified and will begin running its solver loop to resolve\n   * the Spring to equilibrium. Any listeners that are registered\n   * for onSpringEndStateChange will also be notified of this update\n   * immediately.\n   * @public\n   */\n  setEndValue(endValue) {\n    if (this._endValue === endValue && this.isAtRest()) {\n      return this\n    }\n    this._startValue = this.getCurrentValue()\n    this._endValue = endValue\n    this._springSystem.activateSpring(this.getId())\n    for (let i = 0, len = this.listeners.length; i < len; i++) {\n      const listener = this.listeners[i]\n      const onChange = listener.onSpringEndStateChange\n      onChange && onChange(this)\n    }\n    return this\n  }\n\n  /**\n   * Set the current velocity of the Spring, in pixels per second. As\n   * previously mentioned, this can be useful when you are performing\n   * a direct manipulation gesture. When a UI element is released you\n   * may call setVelocity on its animation Spring so that the Spring\n   * continues with the same velocity as the gesture ended with. The\n   * friction, tension, and displacement of the Spring will then\n   * govern its motion to return to rest on a natural feeling curve.\n   * @public\n   */\n  setVelocity(velocity) {\n    if (velocity === this._currentState.velocity) {\n      return this\n    }\n    this._currentState.velocity = velocity\n    this._springSystem.activateSpring(this.getId())\n    return this\n  }\n\n  /**\n   * Enable overshoot clamping. This means that the Spring will stop\n   * immediately when it reaches its resting position regardless of\n   * any existing momentum it may have. This can be useful for certain\n   * types of animations that should not oscillate such as a scale\n   * down to 0 or alpha fade.\n   * @public\n   */\n  setOvershootClampingEnabled(enabled) {\n    this._overshootClampingEnabled = enabled\n    return this\n  }\n\n  /**\n   * Check if the Spring has gone past its end point by comparing\n   * the direction it was moving in when it started to the current\n   * position and end value.\n   * @public\n   */\n  isOvershooting() {\n    const start = this._startValue\n    const end = this._endValue\n    return (\n      this._springConfig.tension > 0 &&\n      ((start < end && this.getCurrentValue() > end) ||\n        (start > end && this.getCurrentValue() < end))\n    )\n  }\n\n  /**\n   * The main solver method for the Spring. It takes\n   * the current time and delta since the last time step and performs\n   * an RK4 integration to get the new position and velocity state\n   * for the Spring based on the tension, friction, velocity, and\n   * displacement of the Spring.\n   * @public\n   */\n  advance(time, realDeltaTime) {\n    let isAtRest = this.isAtRest()\n\n    if (isAtRest && this._wasAtRest) {\n      return\n    }\n\n    let adjustedDeltaTime = realDeltaTime\n    if (realDeltaTime > Spring.MAX_DELTA_TIME_SEC) {\n      adjustedDeltaTime = Spring.MAX_DELTA_TIME_SEC\n    }\n\n    this._timeAccumulator += adjustedDeltaTime\n\n    const tension = this._springConfig.tension\n    const friction = this._springConfig.friction\n    let position = this._currentState.position\n    let velocity = this._currentState.velocity\n    let tempPosition = this._tempState.position\n    let tempVelocity = this._tempState.velocity\n    let aVelocity\n    let aAcceleration\n    let bVelocity\n    let bAcceleration\n    let cVelocity\n    let cAcceleration\n    let dVelocity\n    let dAcceleration\n    let dxdt\n    let dvdt\n\n    while (this._timeAccumulator >= Spring.SOLVER_TIMESTEP_SEC) {\n      this._timeAccumulator -= Spring.SOLVER_TIMESTEP_SEC\n\n      if (this._timeAccumulator < Spring.SOLVER_TIMESTEP_SEC) {\n        this._previousState.position = position\n        this._previousState.velocity = velocity\n      }\n\n      aVelocity = velocity\n      aAcceleration =\n        tension * (this._endValue - tempPosition) - friction * velocity\n\n      tempPosition = position + aVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + aAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5\n      bVelocity = tempVelocity\n      bAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + bVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + bAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5\n      cVelocity = tempVelocity\n      cAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + cVelocity * Spring.SOLVER_TIMESTEP_SEC\n      tempVelocity = velocity + cAcceleration * Spring.SOLVER_TIMESTEP_SEC\n      dVelocity = tempVelocity\n      dAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      dxdt =\n        (1.0 / 6.0) * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity)\n      dvdt =\n        (1.0 / 6.0) *\n        (aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration)\n\n      position += dxdt * Spring.SOLVER_TIMESTEP_SEC\n      velocity += dvdt * Spring.SOLVER_TIMESTEP_SEC\n    }\n\n    this._tempState.position = tempPosition\n    this._tempState.velocity = tempVelocity\n\n    this._currentState.position = position\n    this._currentState.velocity = velocity\n\n    if (this._timeAccumulator > 0) {\n      this._interpolate(this._timeAccumulator / Spring.SOLVER_TIMESTEP_SEC)\n    }\n\n    if (\n      this.isAtRest() ||\n      (this._overshootClampingEnabled && this.isOvershooting())\n    ) {\n      if (this._springConfig.tension > 0) {\n        this._startValue = this._endValue\n        this._currentState.position = this._endValue\n      } else {\n        this._endValue = this._currentState.position\n        this._startValue = this._endValue\n      }\n      this.setVelocity(0)\n      isAtRest = true\n    }\n\n    let notifyActivate = false\n    if (this._wasAtRest) {\n      this._wasAtRest = false\n      notifyActivate = true\n    }\n\n    let notifyAtRest = false\n    if (isAtRest) {\n      this._wasAtRest = true\n      notifyAtRest = true\n    }\n\n    this.notifyPositionUpdated(notifyActivate, notifyAtRest)\n  }\n\n  notifyPositionUpdated(notifyActivate, notifyAtRest) {\n    for (let i = 0, len = this.listeners.length; i < len; i++) {\n      const listener = this.listeners[i]\n\n      if (notifyActivate && listener.onSpringActivate) {\n        listener.onSpringActivate(this)\n      }\n\n      if (listener.onSpringUpdate) {\n        listener.onSpringUpdate(this)\n      }\n\n      if (notifyAtRest && listener.onSpringAtRest) {\n        listener.onSpringAtRest(this)\n      }\n    }\n  }\n\n  /**\n   * Check if the SpringSystem should advance. Springs are advanced\n   * a final frame after they reach equilibrium to ensure that the\n   * currentValue is exactly the requested endValue regardless of the\n   * displacement threshold.\n   * @public\n   */\n  systemShouldAdvance() {\n    return !this.isAtRest() || !this.wasAtRest()\n  }\n\n  wasAtRest() {\n    return this._wasAtRest\n  }\n\n  /**\n   * Check if the Spring is atRest meaning that it's currentValue and\n   * endValue are the same and that it has no velocity. The previously\n   * described thresholds for speed and displacement define the bounds\n   * of this equivalence check. If the Spring has 0 tension, then it will\n   * be considered at rest whenever its absolute velocity drops below the\n   * restSpeedThreshold.\n   * @public\n   */\n  isAtRest() {\n    return (\n      Math.abs(this._currentState.velocity) < this._restSpeedThreshold &&\n      (this.getDisplacementDistanceForState(this._currentState) <=\n        this._displacementFromRestThreshold ||\n        this._springConfig.tension === 0)\n    )\n  }\n\n  _interpolate(alpha) {\n    this._currentState.position =\n      this._currentState.position * alpha +\n      this._previousState.position * (1 - alpha)\n    this._currentState.velocity =\n      this._currentState.velocity * alpha +\n      this._previousState.velocity * (1 - alpha)\n  }\n\n  addListener(newListener) {\n    this.listeners.push(newListener)\n    return this\n  }\n\n  removeListener(listenerToRemove) {\n    removeFirst(this.listeners, listenerToRemove)\n    return this\n  }\n}\n\nSpring._ID = 0\nSpring.MAX_DELTA_TIME_SEC = 0.064\nSpring.SOLVER_TIMESTEP_SEC = 0.001\n\nexport default Spring\n","//\n/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nimport { AnimationLooper } from './Loopers'\nimport Spring from './Spring'\nimport { removeFirst } from './util'\n\n/**\n * A set of Springs that all run on the same physics\n * timing loop. To get started with a Rebound animation, first\n * create a new SpringSystem and then add springs to it.\n * @public\n */\nclass SpringSystem {\n  constructor(looper) {\n    this.looper = looper || new AnimationLooper()\n    this.looper.springSystem = this\n\n    this.listeners = []\n    this._activeSprings = []\n    this._idleSpringIndices = []\n    this._isIdle = true\n    this._lastTimeMillis = -1\n    this._springRegistry = {}\n  }\n\n  /**\n   * Add a new spring to this SpringSystem. This Spring will now be solved for\n   * during the physics iteration loop. By default the spring will use the\n   * default Origami spring config with 40 tension and 7 friction, but you can\n   * also provide your own values here.\n   * @public\n   */\n  createSpring(tension, friction) {\n    return this.createSpringWithConfig({ tension, friction })\n  }\n  /**\n   * Add a spring with the provided SpringConfig.\n   * @public\n   */\n  createSpringWithConfig(springConfig) {\n    const spring = new Spring(this)\n    this.registerSpring(spring)\n    spring.setSpringConfig(springConfig)\n    return spring\n  }\n\n  /**\n   * Check if a SpringSystem is idle or active. If all of the Springs in the\n   * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,\n   * then this method will return true.\n   * @public\n   */\n  getIsIdle() {\n    return this._isIdle\n  }\n\n  /**\n   * Manually add a spring to this system. This is called automatically\n   * if a Spring is created with SpringSystem#createSpring.\n   *\n   * This method sets the spring up in the registry so that it can be solved\n   * in the solver loop.\n   * @public\n   */\n  registerSpring(spring) {\n    this._springRegistry[spring.getId()] = spring\n  }\n\n  /**\n   * Deregister a spring with this SpringSystem. The SpringSystem will\n   * no longer consider this Spring during its integration loop once\n   * this is called. This is normally done automatically for you when\n   * you call Spring#destroy.\n   * @public\n   */\n  deregisterSpring(spring) {\n    removeFirst(this._activeSprings, spring)\n    delete this._springRegistry[spring.getId()]\n  }\n\n  advance(time, deltaTime) {\n    while (this._idleSpringIndices.length > 0) {\n      this._idleSpringIndices.pop()\n    }\n    this._activeSprings.filter(Boolean).forEach(spring => {\n      if (spring.systemShouldAdvance()) {\n        spring.advance(time / 1000.0, deltaTime / 1000.0)\n      } else {\n        this._idleSpringIndices.push(this._activeSprings.indexOf(spring))\n      }\n    })\n\n    while (this._idleSpringIndices.length > 0) {\n      const idx = this._idleSpringIndices.pop()\n      idx >= 0 && this._activeSprings.splice(idx, 1)\n    }\n  }\n\n  /**\n   * This is the main solver loop called to move the simulation\n   * forward through time. Before each pass in the solver loop\n   * onBeforeIntegrate is called on an any listeners that have\n   * registered themeselves with the SpringSystem. This gives you\n   * an opportunity to apply any constraints or adjustments to\n   * the springs that should be enforced before each iteration\n   * loop. Next the advance method is called to move each Spring in\n   * the systemShouldAdvance forward to the current time. After the\n   * integration step runs in advance, onAfterIntegrate is called\n   * on any listeners that have registered themselves with the\n   * SpringSystem. This gives you an opportunity to run any post\n   * integration constraints or adjustments on the Springs in the\n   * SpringSystem.\n   * @public\n   */\n  loop(currentTimeMillis) {\n    let listener\n    if (this._lastTimeMillis === -1) {\n      this._lastTimeMillis = currentTimeMillis - 1\n    }\n    const ellapsedMillis = currentTimeMillis - this._lastTimeMillis\n    this._lastTimeMillis = currentTimeMillis\n\n    let i = 0\n    const len = this.listeners.length\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onBeforeIntegrate && listener.onBeforeIntegrate(this)\n    }\n\n    this.advance(currentTimeMillis, ellapsedMillis)\n    if (this._activeSprings.length === 0) {\n      this._isIdle = true\n      this._lastTimeMillis = -1\n    }\n\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onAfterIntegrate && listener.onAfterIntegrate(this)\n    }\n\n    if (!this._isIdle) {\n      this.looper.run()\n    }\n  }\n\n  /**\n   * Used to notify the SpringSystem that a Spring has become displaced.\n   * The system responds by starting its solver loop up if it is currently idle.\n   */\n  activateSpring(springId) {\n    const spring = this._springRegistry[springId]\n    if (this._activeSprings.indexOf(spring) === -1) {\n      this._activeSprings.push(spring)\n    }\n    if (this.getIsIdle()) {\n      this._isIdle = false\n      this.looper.run()\n    }\n  }\n}\n\nexport default SpringSystem\n","import { SpringSystem } from '../../../forked-rebound'\nimport { StaggerConfigValue } from '../../../Flipper/types'\nimport { FlipData, FlipDataArray } from '../types'\nimport { SpringSystemInterface } from '../../../forked-rebound/types'\n\n// this should get created only 1x\nconst springSystem: SpringSystemInterface = new SpringSystem()\n\nexport const createSuspendedSpring = ({\n  springConfig: { stiffness, damping, overshootClamping },\n  noOp,\n  onSpringActivate,\n  getOnUpdateFunc,\n  onAnimationEnd\n}: FlipData) => {\n  if (noOp) {\n    return null\n  }\n  const spring = springSystem.createSpring(stiffness!, damping!)\n  spring.setOvershootClampingEnabled(!!overshootClamping)\n  spring.addListener({\n    onSpringActivate,\n    onSpringUpdate: getOnUpdateFunc(spring.destroy.bind(spring)),\n    onSpringAtRest: () => {\n      // prevent SpringSystem from caching unused springs\n      spring.destroy()\n      onAnimationEnd()\n    }\n  })\n  return spring\n}\n\nexport const createSpring = (flipped: FlipData) => {\n  const spring = createSuspendedSpring(flipped)\n  if (spring) {\n    spring.setEndValue(1)\n  } else {\n    // even if it was a noop,\n    // we still need to call onSpringActivate in case it calls\n    // cascading flip initiation functions\n    flipped.onSpringActivate()\n  }\n}\n\nexport const normalizeSpeed = (speedConfig: number | undefined) => {\n  if (typeof speedConfig !== 'number') return 1.1\n  return 1 + Math.min(Math.max(speedConfig * 5, 0), 5)\n}\n\nexport const staggeredSprings = (\n  flippedArray: FlipDataArray,\n  staggerConfig: StaggerConfigValue = {}\n) => {\n  if (!flippedArray || !flippedArray.length) {\n    return\n  }\n\n  if (staggerConfig.reverse) {\n    flippedArray.reverse()\n  }\n\n  const normalizedSpeed = normalizeSpeed(staggerConfig.speed)\n\n  const nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10)\n\n  const springFuncs = flippedArray\n    .filter(flipped => !flipped.noOp)\n    .map((flipped, i) => {\n      const cachedGetOnUpdate = flipped.getOnUpdateFunc\n\n      // modify the update function to adjust\n      // the end value of the trailing Flipped component\n      flipped.getOnUpdateFunc = stop => {\n        const onUpdate = cachedGetOnUpdate(stop)\n        return spring => {\n          const currentValue = spring.getCurrentValue()\n          if (currentValue > nextThreshold) {\n            if (springFuncs[i + 1]) {\n              springFuncs[i + 1]!.setEndValue(\n                Math.min(currentValue * normalizedSpeed, 1)\n              )\n            }\n          }\n          // now call the actual update function\n          onUpdate(spring)\n        }\n      }\n      return flipped\n    })\n    .map(flipped => createSuspendedSpring(flipped))\n\n  if (springFuncs[0]) {\n    springFuncs[0]!.setEndValue(1)\n  }\n}\n","import { createSpring, staggeredSprings } from './spring'\nimport {\n  FlipDataDict,\n  TopLevelChildren,\n  InitiateStaggeredAnimations,\n  FlipDataArray,\n  StaggeredChildren,\n  TreeNode\n} from './types'\nimport { StaggerConfig } from '../../Flipper/types'\nimport { FlipId } from '../../Flipped/types'\n\nconst initiateImmediateAnimations = (immediate: FlipDataArray) => {\n  if (!immediate) {\n    return\n  }\n  immediate.forEach(flipped => {\n    createSpring(flipped)\n    initiateImmediateAnimations(flipped.immediateChildren)\n  })\n}\n\nexport const createCallTree = ({\n  flipDataDict,\n  topLevelChildren,\n  initiateStaggeredAnimations\n}: {\n  flipDataDict: FlipDataDict\n  topLevelChildren: TopLevelChildren\n  initiateStaggeredAnimations: InitiateStaggeredAnimations\n}) => {\n  // build a data struct to run the springs\n  const tree = {\n    root: {\n      staggeredChildren: {} as StaggeredChildren,\n      immediateChildren: [] as FlipDataArray\n    }\n  }\n\n  // helper function to build the nested structure\n  const appendChild = (parent: TreeNode, childId: FlipId) => {\n    const flipData = flipDataDict[childId]\n    // might have been filtered (e.g. because it was off screen)\n    if (!flipData) {\n      return\n    }\n\n    if (flipData.stagger) {\n      parent.staggeredChildren[flipData.stagger]\n        ? parent.staggeredChildren[flipData.stagger].push(flipData)\n        : (parent.staggeredChildren[flipData.stagger] = [flipData])\n    } else {\n      parent.immediateChildren.push(flipData)\n    }\n\n    // only when the spring is first activated, activate the child animations as well\n    // this enables nested stagger\n    flipData.onSpringActivate = () => {\n      initiateImmediateAnimations(flipData.immediateChildren)\n      initiateStaggeredAnimations(flipData.staggeredChildren)\n    }\n\n    flipData.staggeredChildren = {}\n    flipData.immediateChildren = []\n\n    flipData.childIds.forEach(childId => appendChild(flipData, childId))\n  }\n\n  // create the nested structure\n  topLevelChildren.forEach(c => {\n    appendChild(tree.root, c)\n  })\n\n  return tree\n}\n\nexport default ({\n  staggerConfig,\n  flipDataDict,\n  topLevelChildren\n}: {\n  staggerConfig: StaggerConfig\n  flipDataDict: FlipDataDict\n  topLevelChildren: TopLevelChildren\n}) => {\n  const initiateStaggeredAnimations: InitiateStaggeredAnimations = staggered => {\n    if (!staggered || !Object.keys(staggered).length) {\n      return\n    }\n    Object.keys(staggered).forEach(staggerKey =>\n      staggeredSprings(staggered[staggerKey], staggerConfig[staggerKey])\n    )\n  }\n\n  const tree = createCallTree({\n    flipDataDict,\n    topLevelChildren,\n    initiateStaggeredAnimations\n  })\n\n  initiateImmediateAnimations(tree.root.immediateChildren)\n  initiateStaggeredAnimations(tree.root.staggeredChildren)\n}\n","import * as Rematrix from 'rematrix'\nimport { getSpringConfig } from '../../springSettings'\nimport {\n  toArray,\n  isFunction,\n  isNumber,\n  getDuplicateValsAsStrings,\n  assign\n} from '../../utilities'\nimport * as constants from '../../constants'\nimport filterFlipDescendants from './filterFlipDescendants'\nimport initiateAnimations from './initiateAnimations'\nimport {\n  GetOnUpdateFunc,\n  OnUpdate,\n  Matrix,\n  InvertedChildren,\n  AnimateFlippedElementsArgs,\n  AnimatedVals,\n  FlipDataArray,\n  FlipData,\n  FlipDataDict,\n  InitializeFlip,\n  TopLevelChildren\n} from './types'\nimport { BoundingClientRect } from '../getFlippedElementPositions/types'\nimport { FlippedIds } from '../types'\nimport { IndexableObject } from '../../utilities/types';\n\n// 3d transforms were causing weird issues in chrome,\n// especially when opacity was also being tweened,\n// so convert to a 2d matrix\nexport const convertMatrix3dArrayTo2dArray = (matrix: Matrix): Matrix =>\n  [0, 1, 4, 5, 12, 13].map(index => matrix[index])\n\nexport const convertMatrix2dArrayToString = (matrix: Matrix) =>\n  `matrix(${matrix.join(', ')})`\n\nexport const invertTransformsForChildren = ({\n  invertedChildren,\n  matrix,\n  body\n}: {\n  matrix: Matrix\n  body: HTMLBodyElement\n  invertedChildren: InvertedChildren\n}) => {\n  invertedChildren.forEach(([child, childFlipConfig]) => {\n    if (!body.contains(child)) {\n      return\n    }\n    const scaleX = matrix[0]\n    const scaleY = matrix[3]\n    const translateX = matrix[4]\n    const translateY = matrix[5]\n\n    const inverseVals = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }\n    let transformString = ''\n    if (childFlipConfig.translate) {\n      inverseVals.translateX = -translateX / scaleX\n      inverseVals.translateY = -translateY / scaleY\n      transformString += `translate(${inverseVals.translateX}px, ${\n        inverseVals.translateY\n      }px)`\n    }\n    if (childFlipConfig.scale) {\n      inverseVals.scaleX = 1 / scaleX\n      inverseVals.scaleY = 1 / scaleY\n      transformString += ` scale(${inverseVals.scaleX}, ${inverseVals.scaleY})`\n    }\n    child.style.transform = transformString\n  })\n}\n\nexport const createApplyStylesFunc = ({\n  element,\n  invertedChildren,\n  body,\n  retainTransform\n}: {\n  element: HTMLElement\n  invertedChildren: InvertedChildren\n  body: HTMLBodyElement\n  retainTransform: boolean\n}) => ({\n  matrix,\n  opacity,\n  forceMinVals\n}: {\n  matrix: Matrix\n  opacity?: number\n  forceMinVals?: boolean\n}) => {\n  if (isNumber(opacity)) {\n    element.style.opacity = opacity + ''\n  }\n\n  if (forceMinVals) {\n    element.style.minHeight = '1px'\n    element.style.minWidth = '1px'\n  }\n\n  if (!matrix) {\n    return\n  }\n\n  const identityTransform = 'matrix(1, 0, 0, 1, 0, 0)'\n  const transformWithInvisibleSkew = 'matrix(1, 0.00001, -0.00001, 1, 0, 0)'\n\n  let stringTransform = convertMatrix2dArrayToString(matrix)\n\n  if (retainTransform && stringTransform === identityTransform) {\n    stringTransform = transformWithInvisibleSkew\n  }\n\n  element.style.transform = stringTransform\n\n  if (invertedChildren) {\n    invertTransformsForChildren({\n      invertedChildren,\n      matrix,\n      body\n    })\n  }\n}\n\nexport const rectInViewport = ({\n  top,\n  bottom,\n  left,\n  right\n}: BoundingClientRect) => {\n  return (\n    top < window.innerHeight &&\n    bottom > 0 &&\n    left < window.innerWidth &&\n    right > 0\n  )\n}\n\nconst getInvertedChildren = (element: HTMLElement, id: string) =>\n  toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}=\"${id}\"]`)\n  )\n\nexport const tweenProp = (start: number, end: number, position: number) =>\n  start + (end - start) * position\n\nexport default ({\n  flippedIds,\n  flipCallbacks,\n  inProgressAnimations,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  applyTransformOrigin,\n  spring,\n  getElement,\n  debug,\n  staggerConfig,\n  decisionData = {},\n  scopedSelector,\n  retainTransform,\n  onComplete\n}: AnimateFlippedElementsArgs) => {\n  // the stuff below is used so we can return a promise that resolves when all FLIP animations have\n  // completed\n  let closureResolve: (flipIds: FlippedIds) => void\n\n  const flipCompletedPromise: Promise<FlippedIds> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n  // hook for users of lib to attach logic when all flip animations have completed\n  if (onComplete) {\n    flipCompletedPromise.then(onComplete)\n  }\n  if (!flippedIds.length) {\n    return () => {\n      closureResolve!([])\n      return flipCompletedPromise\n    }\n  }\n\n  let withInitFuncs: FlipDataArray\n  const completedAnimationIds: FlippedIds = []\n\n  const firstElement: HTMLElement = getElement(flippedIds[0])\n  // special handling for iframes\n  const body = firstElement\n    ? firstElement.ownerDocument!.querySelector('body')!\n    : document.querySelector('body')!\n\n  if (debug) {\n    // eslint-disable-next-line no-console\n    console.error(\n      '[react-flip-toolkit]\\nThe \"debug\" prop is set to true. All FLIP animations will return at the beginning of the transition.'\n    )\n  }\n\n  const duplicateFlipIds = getDuplicateValsAsStrings(flippedIds)\n  if (duplicateFlipIds.length) {\n    // eslint-disable-next-line no-console\n    console.error(\n      `[react-flip-toolkit]\\nThere are currently multiple elements with the same flipId on the page.\\nThe animation will only work if each Flipped component has a unique flipId.\\nDuplicate flipId${\n        duplicateFlipIds.length > 1 ? 's' : ''\n      }: ${duplicateFlipIds.join('\\n')}`\n    )\n  }\n\n  const flipDataArray: FlipDataArray = flippedIds\n    // take all the measurements we need\n    // and return an object with animation functions + necessary data\n    .map(id => {\n      const prevRect = flippedElementPositionsBeforeUpdate[id].rect\n      const currentRect = flippedElementPositionsAfterUpdate[id].rect\n      const prevOpacity = flippedElementPositionsBeforeUpdate[id].opacity\n      const currentOpacity = flippedElementPositionsAfterUpdate[id].opacity\n      const needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1\n\n      // don't animate elements outside of the user's viewport\n      if (!rectInViewport(prevRect) && !rectInViewport(currentRect)) {\n        return false\n      }\n      // it's never going to be visible, so dont animate it\n      if (\n        (prevRect.width === 0 && currentRect.width === 0) ||\n        (prevRect.height === 0 && currentRect.height === 0)\n      ) {\n        return false\n      }\n\n      const element = getElement(id)\n\n      // this might happen if we are rapidly adding & removing elements(?)\n      if (!element) {\n        return false\n      }\n\n      const flipConfig = JSON.parse(element.dataset.flipConfig!)\n\n      const springConfig = getSpringConfig({\n        flipperSpring: spring,\n        flippedSpring: flipConfig.spring\n      })\n\n      const stagger =\n        flipConfig.stagger === true ? 'default' : flipConfig.stagger\n\n      const toReturn = {\n        element,\n        id,\n        stagger,\n        springConfig,\n        noOp: true\n      }\n\n      if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {\n        const elementShouldFlip = flipCallbacks[id].shouldFlip!(\n          decisionData.prev,\n          decisionData.current\n        )\n        // this element wont be animated, but its children might be\n        if (!elementShouldFlip) {\n          return toReturn\n        }\n      }\n\n      // don't animate elements that didn't visbly change\n      // but possibly animate their children\n      const transformDifference =\n        Math.abs(prevRect.left - currentRect.left) +\n        Math.abs(prevRect.top - currentRect.top)\n      const sizeDifference =\n        Math.abs(prevRect.width - currentRect.width) +\n        Math.abs(prevRect.height - currentRect.height)\n      const opacityDifference = Math.abs(currentOpacity - prevOpacity)\n      if (\n        transformDifference < 0.5 &&\n        sizeDifference < 0.5 &&\n        opacityDifference < 0.01\n      ) {\n        // this element wont be animated, but its children might be\n        return toReturn\n      }\n\n      toReturn.noOp = false\n\n      const currentTransform = Rematrix.parse(\n        flippedElementPositionsAfterUpdate[id].transform\n      )\n\n      const toVals: AnimatedVals = { matrix: currentTransform }\n\n      const fromVals: AnimatedVals = { matrix: [] }\n      const transformsArray = [currentTransform]\n\n      // we're only going to animate the values that the child wants animated\n      if (flipConfig.translate) {\n        transformsArray.push(\n          Rematrix.translateX(prevRect.left - currentRect.left)\n        )\n        transformsArray.push(\n          Rematrix.translateY(prevRect.top - currentRect.top)\n        )\n      }\n      // going any smaller than 1px breaks transitions in Chrome\n      if (flipConfig.scale) {\n        transformsArray.push(\n          Rematrix.scaleX(\n            Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)\n          )\n        )\n        transformsArray.push(\n          Rematrix.scaleY(\n            Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)\n          )\n        )\n      }\n\n      if (flipConfig.opacity) {\n        fromVals.opacity = prevOpacity\n        toVals.opacity = currentOpacity\n      }\n\n      let invertedChildren: InvertedChildren = []\n\n      if (\n        !flipCallbacks[id] ||\n        !flipCallbacks[id].shouldInvert ||\n        flipCallbacks[id].shouldInvert!(decisionData.prev, decisionData.current)\n      ) {\n        const invertedChildElements = getInvertedChildren(element, id)\n        invertedChildren = invertedChildElements.map(c => [\n          c,\n          JSON.parse(c.dataset.flipConfig!)\n        ]) as InvertedChildren\n      }\n\n      fromVals.matrix = convertMatrix3dArrayTo2dArray(\n        transformsArray.reduce(Rematrix.multiply)\n      )\n\n      toVals.matrix = convertMatrix3dArrayTo2dArray(toVals.matrix)\n\n      const applyStyles = createApplyStylesFunc({\n        element,\n        invertedChildren,\n        body,\n        retainTransform\n      })\n\n      let onComplete: () => void\n      if (flipCallbacks[id] && flipCallbacks[id].onComplete) {\n        // must cache or else this could cause an error\n        const cachedOnComplete = flipCallbacks[id].onComplete\n        onComplete = () =>\n          cachedOnComplete!(element, decisionData.prev, decisionData.current)\n      }\n\n      // this should be called when animation ends naturally\n      // but also when it is interrupted\n      // when it is called, the animation has already been cancelled\n      const onAnimationEnd = () => {\n        delete inProgressAnimations[id]\n        if (isFunction(onComplete)) {\n          onComplete()\n        }\n        // remove identity transform -- this should have no effect on layout\n        element.style.transform = ''\n        if (needsForcedMinVals && element) {\n          element.style.minHeight = ''\n          element.style.minWidth = ''\n        }\n        completedAnimationIds.push(id)\n\n        if (completedAnimationIds.length >= withInitFuncs.length) {\n          // we can theoretically call multiple times since a promise only resolves 1x\n          // but that shouldnt happen\n          closureResolve(completedAnimationIds)\n        }\n      }\n\n      const animateOpacity =\n        isNumber(fromVals.opacity) &&\n        isNumber(toVals.opacity) &&\n        fromVals.opacity !== toVals.opacity\n\n      let onStartCalled = false\n\n      const getOnUpdateFunc: GetOnUpdateFunc = stop => {\n        inProgressAnimations[id] = {\n          stop,\n          onComplete\n        }\n        const onUpdate: OnUpdate = spring => {\n          if (flipCallbacks[id] && flipCallbacks[id].onSpringUpdate) {\n            flipCallbacks[id].onSpringUpdate!(spring.getCurrentValue())\n          }\n          // trigger the user provided onStart function\n          if (!onStartCalled) {\n            onStartCalled = true\n            if (flipCallbacks[id] && flipCallbacks[id].onStart) {\n              flipCallbacks[id].onStart!(\n                element,\n                decisionData.prev,\n                decisionData.current\n              )\n            }\n          }\n\n          const currentValue = spring.getCurrentValue()\n\n          if (!body.contains(element)) {\n            stop()\n            return\n          }\n\n          const vals: AnimatedVals = { matrix: [] }\n\n          vals.matrix = fromVals.matrix.map((fromVal, index) =>\n            tweenProp(fromVal, toVals.matrix[index], currentValue)\n          )\n\n          if (animateOpacity) {\n            vals.opacity = tweenProp(\n              fromVals.opacity!,\n              toVals.opacity!,\n              currentValue\n            )\n          }\n          applyStyles(vals)\n        }\n        return onUpdate\n      }\n\n      const initializeFlip: InitializeFlip = () => {\n        // before animating, immediately apply FLIP styles to prevent flicker\n        applyStyles({\n          matrix: fromVals.matrix,\n          opacity: animateOpacity ? fromVals.opacity : undefined,\n          forceMinVals: needsForcedMinVals\n        })\n        if (flipCallbacks[id] && flipCallbacks[id].onStartImmediate) {\n          flipCallbacks[id].onStartImmediate!(\n            element,\n            decisionData.prev,\n            decisionData.current\n          )\n        }\n        // and batch any other style updates if necessary\n        if (flipConfig.transformOrigin) {\n          element.style.transformOrigin = flipConfig.transformOrigin\n        } else if (applyTransformOrigin) {\n          element.style.transformOrigin = '0 0'\n        }\n\n        invertedChildren.forEach(([child, childFlipConfig]) => {\n          if (childFlipConfig.transformOrigin) {\n            child.style.transformOrigin = childFlipConfig.transformOrigin\n          } else if (applyTransformOrigin) {\n            child.style.transformOrigin = '0 0'\n          }\n        })\n      }\n\n      return assign({}, toReturn, {\n        stagger,\n        springConfig,\n        getOnUpdateFunc,\n        initializeFlip,\n        onAnimationEnd\n      }) as FlipData\n    })\n    // filter out data for all non-animated elements first\n    .filter(x => x) as FlipDataArray\n\n  // we use this array to compare with completed animations\n  // to decide when all animations are completed\n  withInitFuncs = flipDataArray.filter(({ initializeFlip }) =>\n    Boolean(initializeFlip)\n  )\n  //  put items back in place\n  withInitFuncs.forEach(({ initializeFlip }) => initializeFlip())\n\n  if (debug) {\n    return () => {}\n  }\n\n  const flipDataDict: FlipDataDict = flipDataArray.reduce((acc:IndexableObject, curr) => {\n    acc[curr.id] = curr\n    return acc\n  }, {})\n\n  // this function modifies flipDataDict in-place\n  // by removing references to non-direct children\n  // to enable recursive stagger\n  const topLevelChildren: TopLevelChildren = filterFlipDescendants({\n    flipDataDict,\n    flippedIds,\n    scopedSelector\n  })\n\n  return () => {\n    // there are no active FLIP animations, so immediately resolve the\n    // returned promise\n    if (!withInitFuncs.length) {\n      closureResolve([])\n    }\n    initiateAnimations({ topLevelChildren, flipDataDict, staggerConfig })\n    return flipCompletedPromise\n  }\n}\n","import { toArray, assign } from '../../utilities'\nimport * as constants from '../../constants'\n\nexport const addTupleToObject = (acc: {}, curr: [any, any]) =>\n  assign(acc, { [curr[0]]: curr[1] })\n\nexport const getAllElements = (\n  element?: HTMLElement,\n  portalKey?: string\n): HTMLElement[] => {\n  if (portalKey) {\n    return toArray(\n      document.querySelectorAll(`[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]`)\n    )\n  } else {\n    return toArray(element!.querySelectorAll(`[${constants.DATA_FLIP_ID}]`))\n  }\n}\n","import React, { Component, createContext } from 'react'\nimport PropTypes from 'prop-types'\nimport onFlipKeyUpdate from '../flip'\nimport getFlippedElementPositionsBeforeUpdate from '../flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate'\nimport { FlipperProps, InProgressAnimations, FlipCallbacks } from './types'\nimport { FlippedElementPositionsBeforeUpdateReturnVals } from '../flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/types'\n\nexport const FlipContext = createContext({} as FlipCallbacks)\nexport const PortalContext = createContext('portal')\n\nclass Flipper extends Component<FlipperProps> {\n  static defaultProps = {\n    applyTransformOrigin: true,\n    element: 'div',\n    retainTransform: false\n  }\n\n  private inProgressAnimations: InProgressAnimations = {}\n  private flipCallbacks: FlipCallbacks = {}\n  private el?: HTMLElement = undefined\n\n  getSnapshotBeforeUpdate(prevProps: FlipperProps) {\n    if (prevProps.flipKey !== this.props.flipKey && this.el) {\n      return getFlippedElementPositionsBeforeUpdate({\n        element: this.el,\n        // if onExit callbacks exist here, we'll cache the DOM node\n        flipCallbacks: this.flipCallbacks,\n        inProgressAnimations: this.inProgressAnimations,\n        portalKey: this.props.portalKey\n      })\n    }\n    return null\n  }\n\n  componentDidUpdate(\n    prevProps: FlipperProps,\n    _prevState: any,\n    cachedData: FlippedElementPositionsBeforeUpdateReturnVals\n  ) {\n    if (this.props.flipKey !== prevProps.flipKey && this.el) {\n      onFlipKeyUpdate({\n        flippedElementPositionsBeforeUpdate: cachedData.flippedElementPositions,\n        cachedOrderedFlipIds: cachedData.cachedOrderedFlipIds,\n        containerEl: this.el,\n        inProgressAnimations: this.inProgressAnimations,\n        flipCallbacks: this.flipCallbacks,\n        applyTransformOrigin: this.props.applyTransformOrigin,\n        spring: this.props.spring,\n        debug: this.props.debug,\n        portalKey: this.props.portalKey,\n        staggerConfig: this.props.staggerConfig,\n        handleEnterUpdateDelete: this.props.handleEnterUpdateDelete,\n        // typescript doesn't recognize defaultProps (?)\n        retainTransform: this.props.retainTransform!,\n        decisionData: {\n          prev: prevProps.decisionData,\n          current: this.props.decisionData\n        },\n        onComplete: this.props.onComplete\n      })\n    }\n  }\n\n  render() {\n    const { element, className, portalKey } = this.props\n    const Element = element\n\n    const FlipperBase = (\n      <FlipContext.Provider value={this.flipCallbacks}>\n        {/*\n        // @ts-ignore */}\n        <Element\n          className={className}\n          ref={(el: HTMLElement) => (this.el = el)}\n        >\n          {this.props.children}\n        </Element>\n      </FlipContext.Provider>\n    )\n\n    if (portalKey) {\n      return (\n        <PortalContext.Provider value={portalKey}>\n          {FlipperBase}\n        </PortalContext.Provider>\n      )\n    } else {\n      return FlipperBase\n    }\n  }\n}\n// @ts-ignore\nFlipper.propTypes = {\n  flipKey: PropTypes.any,\n  children: PropTypes.node.isRequired,\n  spring: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  applyTransformOrigin: PropTypes.bool,\n  debug: PropTypes.bool,\n  element: PropTypes.string,\n  className: PropTypes.string,\n  portalKey: PropTypes.string,\n  staggerConfig: PropTypes.object,\n  decisionData: PropTypes.any,\n  handleEnterUpdateDelete: PropTypes.func,\n  retainTransform: PropTypes.bool,\n  onComplete: PropTypes.func\n}\n\nexport default Flipper\n","import { addTupleToObject, getAllElements } from '../utilities'\nimport * as constants from '../../../constants'\nimport { toArray, assign } from '../../../utilities'\nimport {\n  FlippedElementPositionsBeforeUpdateReturnVals,\n  FlippedElementPositionsBeforeUpdate,\n  GetFlippedElementPositionsBeforeUpdateArgs,\n  ParentBCRs,\n  ChildIdsToParentBCRs,\n  ChildIdsToParents\n} from './types'\nimport { InProgressAnimations } from '../../../Flipper/types'\n\nconst cancelInProgressAnimations = (\n  inProgressAnimations: InProgressAnimations\n) => {\n  Object.keys(inProgressAnimations).forEach(id => {\n    if (inProgressAnimations[id].stop) {\n      inProgressAnimations[id].stop()\n    }\n    delete inProgressAnimations[id]\n  })\n}\n\nconst getFlippedElementPositionsBeforeUpdate = ({\n  element,\n  flipCallbacks = {},\n  inProgressAnimations = {},\n  portalKey\n}: GetFlippedElementPositionsBeforeUpdateArgs): FlippedElementPositionsBeforeUpdateReturnVals => {\n  const flippedElements = getAllElements(element, portalKey)\n\n  const inverseFlippedElements = toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}]`)\n  )\n\n  const childIdsToParentBCRs: ChildIdsToParentBCRs = {}\n  const parentBCRs: ParentBCRs = []\n  const childIdsToParents: ChildIdsToParents = {}\n  // this is for exit animations so we can re-insert exiting elements in the\n  // DOM later\n  flippedElements\n    .filter(\n      el =>\n        flipCallbacks &&\n        flipCallbacks[el.dataset.flipId!] &&\n        flipCallbacks[el.dataset.flipId!].onExit\n    )\n    .forEach(el => {\n      let parent = el.parentNode as HTMLElement\n      // this won't work for IE11\n      if (el.closest) {\n        const exitContainer = el.closest(\n          `[${constants.DATA_EXIT_CONTAINER}]`\n        ) as HTMLElement\n        if (exitContainer) {\n          parent = exitContainer\n        }\n      }\n      let bcrIndex = parentBCRs.findIndex(n => n[0] === parent)\n      if (bcrIndex === -1) {\n        parentBCRs.push([parent, parent.getBoundingClientRect()])\n        bcrIndex = parentBCRs.length - 1\n      }\n      childIdsToParentBCRs[el.dataset.flipId!] = parentBCRs[bcrIndex][1]\n      childIdsToParents[el.dataset.flipId!] = parent\n    })\n\n  const flippedElementPositions: FlippedElementPositionsBeforeUpdate = flippedElements\n    .map(child => {\n      const domDataForExitAnimations = {}\n      const childBCR = child.getBoundingClientRect()\n\n      // only cache extra data for exit animations\n      // if the element has an onExit listener\n      if (\n        flipCallbacks &&\n        flipCallbacks[child.dataset.flipId!] &&\n        flipCallbacks[child.dataset.flipId!].onExit\n      ) {\n        const parentBCR = childIdsToParentBCRs[child.dataset.flipId!]\n\n        assign(domDataForExitAnimations, {\n          element: child,\n          parent: childIdsToParents[child.dataset.flipId!],\n          childPosition: {\n            top: childBCR.top - parentBCR.top,\n            left: childBCR.left - parentBCR.left,\n            width: childBCR.width,\n            height: childBCR.height\n          }\n        })\n      }\n\n      return [\n        child.dataset.flipId,\n        {\n          rect: childBCR,\n          opacity: parseFloat(window.getComputedStyle(child).opacity || '1'),\n          domDataForExitAnimations\n        }\n      ]\n    })\n    // @ts-ignore\n    .reduce(addTupleToObject, {})\n\n  // do this at the very end since we want to cache positions of elements\n  // while they are mid-transition\n  cancelInProgressAnimations(inProgressAnimations)\n\n  flippedElements.concat(inverseFlippedElements).forEach(el => {\n    el.style.transform = ''\n    el.style.opacity = ''\n  })\n  return {\n    flippedElementPositions,\n    cachedOrderedFlipIds: flippedElements.map(el => el.dataset.flipId!)\n  }\n}\n\nexport default getFlippedElementPositionsBeforeUpdate\n","import animateUnflippedElements from './animateUnflippedElements'\nimport animateFlippedElements from './animateFlippedElements'\nimport getFlippedElementPositionsAfterUpdate from './getFlippedElementPositions/getFlippedElementPositionsAfterUpdate'\nimport * as constants from '../constants'\nimport { assign, toArray } from '../utilities'\nimport {\n  GetElement,\n  BaseFlipArgs,\n  OnFlipKeyUpdateArgs,\n  FlippedIds\n} from './types'\nimport { AnimateUnflippedElementsArgs } from './animateUnflippedElements/types'\nimport {\n  AnimateFlippedElementsArgs,\n  ScopedSelector\n} from './animateFlippedElements/types'\n\nconst createPortalScopedSelector = (portalKey: string) => (\n  selector: string\n) => {\n  return toArray(\n    document.querySelectorAll(\n      `[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]${selector}`\n    )\n  )\n}\nconst createFlipperScopedSelector = (containerEl: HTMLElement) => {\n  const tempFlipperId = Math.random().toFixed(5)\n  containerEl.dataset.flipperId = tempFlipperId\n\n  return (selector: string) => {\n    return toArray(\n      containerEl.querySelectorAll(\n        `[data-flipper-id=\"${tempFlipperId}\"] ${selector}`\n      )\n    )\n  }\n}\nconst createScopedSelector = ({\n  containerEl,\n  portalKey\n}: {\n  containerEl?: HTMLElement\n  portalKey?: string\n}): ScopedSelector => {\n  if (portalKey) {\n    return createPortalScopedSelector(portalKey)\n  } else if (containerEl) {\n    return createFlipperScopedSelector(containerEl)\n  } else {\n    return () => []\n  }\n}\n\nconst createGetElementFunc = (scopedSelector: ScopedSelector): GetElement => {\n  return (id: string) => {\n    return scopedSelector(`[${constants.DATA_FLIP_ID}=\"${id}\"]`)[0]\n  }\n}\n\nconst onFlipKeyUpdate = ({\n  cachedOrderedFlipIds = [],\n  inProgressAnimations = {},\n  flippedElementPositionsBeforeUpdate = {},\n  flipCallbacks = {},\n  containerEl,\n  applyTransformOrigin,\n  spring,\n  debug,\n  portalKey,\n  staggerConfig = {},\n  decisionData = {},\n  handleEnterUpdateDelete,\n  retainTransform,\n  onComplete\n}: OnFlipKeyUpdateArgs) => {\n  const flippedElementPositionsAfterUpdate = getFlippedElementPositionsAfterUpdate(\n    {\n      element: containerEl,\n      portalKey\n    }\n  )\n\n  const scopedSelector = createScopedSelector({\n    containerEl,\n    portalKey\n  })\n  const getElement = createGetElementFunc(scopedSelector)\n\n  const isFlipped = (id: string) =>\n    flippedElementPositionsBeforeUpdate[id] &&\n    flippedElementPositionsAfterUpdate[id]\n\n  const unflippedIds = Object.keys(flippedElementPositionsBeforeUpdate)\n    .concat(Object.keys(flippedElementPositionsAfterUpdate))\n    .filter(id => !isFlipped(id))\n\n  const baseArgs: BaseFlipArgs = {\n    flipCallbacks,\n    getElement,\n    flippedElementPositionsBeforeUpdate,\n    flippedElementPositionsAfterUpdate,\n    inProgressAnimations\n  }\n\n  const animateUnFlippedElementsArgs = assign(\n    {},\n    baseArgs,\n    {\n      unflippedIds\n    }\n  ) as AnimateUnflippedElementsArgs\n\n  const {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  } = animateUnflippedElements(animateUnFlippedElementsArgs)\n\n  const flippedIds: FlippedIds = cachedOrderedFlipIds.filter(isFlipped)\n  // @ts-ignore\n  const animateFlippedElementsArgs: AnimateFlippedElementsArgs = assign(\n    {},\n    baseArgs,\n    {\n      flippedIds,\n      applyTransformOrigin,\n      spring,\n      debug,\n      staggerConfig,\n      decisionData,\n      scopedSelector,\n      retainTransform,\n      onComplete\n    }\n  )\n\n  // the function handles putting flipped elements back in their original positions\n  // and returns another function to actually call the flip animation\n  const flip = animateFlippedElements(animateFlippedElementsArgs)\n\n  // clear temp markup that was added to facilitate FLIP\n  // namely, in the filterFlipDescendants function\n  const cleanupTempDataAttributes = () => {\n    unflippedIds\n      .filter(id => flippedElementPositionsAfterUpdate[id])\n      .forEach(id => {\n        const element = getElement(id)\n        if (element) {\n          element.removeAttribute(constants.DATA_IS_APPEARING)\n        }\n      })\n  }\n\n  cleanupTempDataAttributes()\n\n  if (handleEnterUpdateDelete) {\n    handleEnterUpdateDelete({\n      hideEnteringElements,\n      animateEnteringElements,\n      animateExitingElements,\n      animateFlippedElements: flip\n    })\n  } else {\n    hideEnteringElements()\n    animateExitingElements().then(animateEnteringElements)\n    flip()\n  }\n}\n\nexport default onFlipKeyUpdate\n","import { addTupleToObject, getAllElements } from '../utilities'\nimport { FlippedElementPositionsAfterUpdate } from './types'\n\nconst getFlippedElementPositionsAfterUpdate = ({\n  element,\n  portalKey\n}: {\n  element: HTMLElement\n  portalKey?: string\n}): FlippedElementPositionsAfterUpdate => {\n  return (\n    getAllElements(element, portalKey)\n      .map(child => {\n        const computedStyle = window.getComputedStyle(child)\n        const rect = child.getBoundingClientRect()\n        return [\n          child.dataset.flipId,\n          {\n            rect,\n            opacity: parseFloat(computedStyle.opacity!),\n            transform: computedStyle.transform\n          }\n        ]\n      })\n      // @ts-ignore\n      .reduce(addTupleToObject, {})\n  )\n}\n\nexport default getFlippedElementPositionsAfterUpdate\n","export const DATA_FLIP_ID = 'data-flip-id'\nexport const DATA_INVERSE_FLIP_ID = 'data-inverse-flip-id'\nexport const DATA_FLIP_COMPONENT_ID = 'data-flip-component-id'\nexport const DATA_FLIP_CONFIG = 'data-flip-config'\nexport const DATA_PORTAL_KEY = 'data-portal-key'\nexport const DATA_EXIT_CONTAINER = 'data-exit-container'\nexport const DATA_IS_APPEARING = 'data-is-appearing'\n","import React, {\n  FunctionComponent,\n  Children,\n  cloneElement,\n  ReactElement\n} from 'react'\nimport PropTypes from 'prop-types'\nimport { FlipContext, PortalContext } from '../Flipper'\nimport * as constants from '../constants'\nimport { assign, isObject } from '../utilities'\nimport { FlippedProps, SerializableFlippedProps } from './types'\nimport { IndexableObject } from '../utilities/types'\n\nconst propTypes = {\n  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n  inverseFlipId: PropTypes.string,\n  flipId: PropTypes.string,\n  opacity: PropTypes.bool,\n  translate: PropTypes.bool,\n  scale: PropTypes.bool,\n  transformOrigin: PropTypes.string,\n  spring: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  onStart: PropTypes.func,\n  onComplete: PropTypes.func,\n  onAppear: PropTypes.func,\n  onSpringUpdate: PropTypes.func,\n  shouldFlip: PropTypes.func,\n  shouldInvert: PropTypes.func,\n  onExit: PropTypes.func,\n  portalKey: PropTypes.string,\n  stagger: PropTypes.oneOfType([PropTypes.string, PropTypes.bool])\n}\n\nfunction isFunction(child: any): child is Function {\n  return typeof child === 'function'\n}\n// This wrapper creates child components for the main Flipper component\nexport const Flipped = ({\n  children,\n  flipId,\n  inverseFlipId,\n  portalKey,\n  ...rest\n}: SerializableFlippedProps): ReactElement<any> => {\n  let child = children\n  const isFunctionAsChildren = isFunction(child)\n\n  if (!isFunctionAsChildren) {\n    try {\n      child = Children.only(children)\n    } catch (e) {\n      throw new Error('Each Flipped component must wrap a single child')\n    }\n  }\n\n  // if nothing is being animated, assume everything is being animated\n  if (!rest.scale && !rest.translate && !rest.opacity) {\n    assign(rest, {\n      translate: true,\n      scale: true,\n      opacity: true\n    })\n  }\n\n  const dataAttributes: IndexableObject = {\n    // these are both used as selectors so they have to be separate\n    [constants.DATA_FLIP_ID]: flipId,\n    [constants.DATA_INVERSE_FLIP_ID]: inverseFlipId,\n    [constants.DATA_FLIP_CONFIG]: JSON.stringify(rest)\n  }\n\n  if (portalKey) {\n    dataAttributes[constants.DATA_PORTAL_KEY] = portalKey\n  }\n  if (isFunctionAsChildren) {\n    return (child as Function)(dataAttributes)\n  }\n  return cloneElement(child as ReactElement<any>, dataAttributes)\n}\n\n// @ts-ignore\nexport const FlippedWithContext: FunctionComponent<FlippedProps> = ({\n  children,\n  flipId,\n  shouldFlip,\n  shouldInvert,\n  onAppear,\n  onStart,\n  onStartImmediate,\n  onComplete,\n  onExit,\n  onSpringUpdate,\n  ...rest\n}) => {\n  if (!children) {\n    return null\n  }\n  if (rest.inverseFlipId) {\n    return <Flipped {...rest}>{children}</Flipped>\n  }\n  return (\n    <PortalContext.Consumer>\n      {portalKey => (\n        <FlipContext.Consumer>\n          {data => {\n            // if there is no surrounding Flipper component,\n            // we don't want to throw an error, so check\n            // that data exists and is not the default string\n            if (isObject(data)) {\n              // @ts-ignore\n              data[flipId as string] = {\n                shouldFlip,\n                shouldInvert,\n                onAppear,\n                onStart,\n                onStartImmediate,\n                onComplete,\n                onExit,\n                onSpringUpdate\n              }\n            }\n            return (\n              <Flipped flipId={flipId} {...rest} portalKey={portalKey}>\n                {children}\n              </Flipped>\n            )\n          }}\n        </FlipContext.Consumer>\n      )}\n    </PortalContext.Consumer>\n  )\n}\n// @ts-ignore\nFlippedWithContext.propTypes = propTypes\n\nexport default FlippedWithContext\n","import { FunctionComponent, cloneElement, ReactElement } from 'react'\nimport { DATA_EXIT_CONTAINER } from '../constants'\n\nconst ExitContainer: FunctionComponent = ({ children }) => {\n  return cloneElement(children as ReactElement<any>, {\n    [DATA_EXIT_CONTAINER]: true\n  })\n}\n\nexport default ExitContainer\n"],"names":["const","isNumber","x","isObject","Object","prototype","toString","call","toArray","arrayLike","Array","slice","apply","assign","target","args","forEach","arg","nextKey","hasOwnProperty","_onFrame","springPresets","noWobble","stiffness","damping","gentle","veryGentle","wobbly","stiff","selectFlipChildIds","scopedSelector","selector","flippedIds","childIds","map","el","dataset","flipId","filter","id","indexOf","baseSelector","window","requestAnimationFrame","callback","setTimeout","start","Date","now","performanceNow","performance","removeFirst","array","item","idx","splice","AnimationLooper","run","springSystem","loop","PhysicsState","constructor","position","velocity","Spring","_id","_ID","_springSystem","listeners","_startValue","_currentState","_displacementFromRestThreshold","_endValue","_overshootClampingEnabled","_previousState","_restSpeedThreshold","_tempState","_timeAccumulator","_wasAtRest","getId","this","destroy","deregisterSpring","setSpringConfig","springConfig","_springConfig","getCurrentValue","getDisplacementDistanceForState","state","Math","abs","setEndValue","endValue","isAtRest","activateSpring","let","i","len","length","onChange","onSpringEndStateChange","setVelocity","setOvershootClampingEnabled","enabled","isOvershooting","end","tension","advance","time","realDeltaTime","adjustedDeltaTime","MAX_DELTA_TIME_SEC","aVelocity","aAcceleration","bVelocity","bAcceleration","cVelocity","cAcceleration","friction","tempPosition","tempVelocity","SOLVER_TIMESTEP_SEC","_interpolate","notifyActivate","notifyAtRest","notifyPositionUpdated","listener","onSpringActivate","onSpringUpdate","onSpringAtRest","systemShouldAdvance","wasAtRest","alpha","addListener","newListener","push","removeListener","listenerToRemove","SpringSystem","looper","_activeSprings","_idleSpringIndices","_isIdle","_lastTimeMillis","_springRegistry","createSpring","createSpringWithConfig","spring","registerSpring","getIsIdle","deltaTime","pop","Boolean","currentTimeMillis","ellapsedMillis","onBeforeIntegrate","onAfterIntegrate","springId","createSuspendedSpring","ref","overshootClamping","getOnUpdateFunc","bind","onAnimationEnd","initiateImmediateAnimations","immediate","flipped","immediateChildren","convertMatrix3dArrayTo2dArray","matrix","index","rectInViewport","innerHeight","innerWidth","tweenProp","addTupleToObject","acc","curr","getAllElements","element","portalKey","document","querySelectorAll","FlipContext","createContext","PortalContext","Flipper","undefined","getSnapshotBeforeUpdate","prevProps","flipKey","props","flippedElements","inverseFlippedElements","childIdsToParentBCRs","parentBCRs","childIdsToParents","flipCallbacks","onExit","parent","parentNode","closest","exitContainer","bcrIndex","findIndex","n","getBoundingClientRect","flippedElementPositions","child","domDataForExitAnimations","childBCR","parentBCR","childPosition","top","left","width","height","rect","opacity","parseFloat","getComputedStyle","reduce","inProgressAnimations","keys","stop","cancelInProgressAnimations","concat","style","transform","cachedOrderedFlipIds","getFlippedElementPositionsBeforeUpdate","componentDidUpdate","_prevState","cachedData","flippedElementPositionsAfterUpdate","computedStyle","getFlippedElementPositionsAfterUpdate","containerEl","createPortalScopedSelector","tempFlipperId","random","toFixed","flipperId","createFlipperScopedSelector","createScopedSelector","getElement","createGetElementFunc","isFlipped","flippedElementPositionsBeforeUpdate","unflippedIds","baseArgs","enteringElementIds","animatedEnteringElementIds","onAppear","animatedExitingElementIds","isAppearing","closureResolve","promiseToReturn","Promise","resolve","fragmentTuples","exitingElementCount","onExitCallbacks","fragmentTuple","t","createDocumentFragment","appendChild","removeChild","DOMException","c","animateUnflippedElements","flip","withInitFuncs","flipCompletedPromise","onComplete","then","completedAnimationIds","firstElement","body","ownerDocument","querySelector","debug","console","error","obj","duplicateFlipIds","val","join","flipDataArray","prevRect","currentRect","prevOpacity","currentOpacity","needsForcedMinVals","flipConfig","JSON","parse","normalizeSpring","flippedSpring","getSpringConfig","flipperSpring","stagger","toReturn","noOp","shouldFlip","decisionData","prev","current","transformDifference","sizeDifference","opacityDifference","currentTransform","Rematrix","toVals","fromVals","transformsArray","translate","scale","max","invertedChildren","shouldInvert","invertedChildElements","getInvertedChildren","applyStyles","forceMinVals","minHeight","minWidth","stringTransform","convertMatrix2dArrayToString","retainTransform","contains","scaleX","scaleY","translateY","inverseVals","translateX","transformString","childFlipConfig","invertTransformsForChildren","createApplyStylesFunc","cachedOnComplete","animateOpacity","onStartCalled","onStart","currentValue","vals","fromVal","onStartImmediate","transformOrigin","applyTransformOrigin","initializeFlip","flipDataDict","topLevelChildren","levelToChildren","buildHierarchy","level","oldResult","newSelector","newResult","oldLevelChildren","childId","data","filterFlipDescendants","initiateStaggeredAnimations","staggered","staggerKey","flippedArray","staggerConfig","reverse","speedConfig","normalizedSpeed","speed","min","nextThreshold","springFuncs","cachedGetOnUpdate","onUpdate","staggeredSprings","tree","root","staggeredChildren","flipData","createCallTree","initiateAnimations","animateFlippedElements","removeAttribute","handleEnterUpdateDelete","hideEnteringElements","animateEnteringElements","animateExitingElements","onFlipKeyUpdate","render","FlipperBase","React","Provider","value","className","children","Component","propTypes","PropTypes","any","node","isRequired","oneOfType","string","object","bool","func","inverseFlipId","Flipped","isFunctionAsChildren","isFunction","Children","only","e","Error","rest","dataAttributes","stringify","cloneElement","FlippedWithContext","Consumer","ExitContainer"],"mappings":"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"}